/*************************************************************************
 *
 * This file is part of the SAMRAI distribution.  For full copyright 
 * information, see COPYRIGHT and LICENSE. 
 *
 * Copyright:     (c) 1997-2024 Lawrence Livermore National Security, LLC
 * Description:   Input file for DLBG tests.
 *
 ************************************************************************/

Main {
  // Dimension of problem.
  dim = 2

  // If TRUE, computes and checks Connectors.
  check_dlbg_in_main = FALSE

  // Base name of log file.
  base_name = "front.2d"

  // Base name of visualization files.  If not supplied, determined by
  // base_name.
  // vis_filename = "front.2d"

  // Name of log file(s).  If not supplied, determined by base_name.
  // log_filename = "front.2d.log"

  // If true log all nodes, otherwise only log node 0.
  log_all = TRUE

  // Time step frequency at which to plot.
  plot_step = 1

  // If TRUE, perform recursivePrint on patch hierarchy.
  log_hierarchy = TRUE

  // Number of time steps.
  num_steps = 50

  // 
  build_cross_edge = TRUE

  // 
  build_peer_edge = TRUE

  // Controls amount of logging info generated by each BoxLevel.  A negative
  // value means no info, 0 means minimal info, and anything > 0 means all
  // info.
  node_log_detail = 2

  // If TRUE, all BoxLevels are globalized prior to construction of Connectors.
  globalize_box_levels = FALSE

  // Controls amount of logging info generatted by each Connector.  A negative
  // value means no info.  Verbosity increase with the value.  Maximum info
  // is generated when value is > 1.
  edge_log_detail = 3

  // Regridding tag buffer.
  tag_buffer = 1, 1, 1, 1, 1, 1, 1, 1

  // If > 0 turns on more output.
  verbose = 0
}

DLBGTest {
  // Input for SinusoidalFrontGenerator.  If anything other than sine_tagger is
  // specified (or there is nothing) the SinusoidalFrontGenerator's defaults are
  // used.  See testlib/SinusoidalFrontGenerator for input parameter details.
  sine_tagger {
    // Period of tagging sinusoid.
    period = 1.0, 1.0

    // Amplitude of tagging sinusoid.
    amplitude = .3

    // Front initial displacement.
    init_disp = -0.42, 0.0
    // init_disp = 0.5, 0.0

    // Front velocity.
    velocity = 0.015, 0.010

    // Tagging buffer, in physical space units.
    buffer_distance_0 = 0.2, 0.2
    buffer_distance_1 = 0.1, 0.1
    buffer_distance_2 = 0.05, 0.05
    buffer_distance_3 = 0.00, 0.00
  }
}


// Refer to mesh::BergerRigoutsos for input
BergerRigoutsos {
  DEV_log_node_history = FALSE
  DEV_log_cluster_summary = TRUE
  DEV_log_cluster = FALSE
  // DEV_algo_advance_mode: "SYNCHRONOUS", "ADVANCE_SOME", "ROUND_ROBIN" or "ADVANCE_ANY"
  DEV_algo_advance_mode = "ADVANCE_SOME"
  // DEV_algo_advance_mode = "SYNCHRONOUS"
  // DEV_owner_mode: "SINGLE_OWNER", "MOST_OVERLAP" (default), "FEWEST_OWNED", "LEAST_ACTIVE"
  // DEV_owner_mode = "FEWEST_OWNED"
  DEV_owner_mode = "MOST_OVERLAP"
  // DEV_owner_mode = "SINGLE_OWNER"
  max_box_size = 40, 40
  efficiency_tolerance = 0.80
  combine_efficiency = 0.75
}


// Refer to geom::CartesianGeometry and its base clases for input
CartesianGridGeometry {
  // domain_boxes = [(0,0), (3,3)]
  // domain_boxes = [(0,0), (15,31)]
  // domain_boxes = [(0,0), (15,15)], [(1,16), (16,31)]
  domain_boxes = [(0,0), (7,15)], [(8,-1), (15,14)], [(2,16), (9,31)], [(10,15), (17,30)]
  x_lo         = 0, 0
  x_up         = 1, 2
  periodic_dimension = 0, 0
}

// Refer to mesh::StandardTagAndInitialize for input
StandardTagAndInitialize {
  tagging_method = "GRADIENT_DETECTOR"
}

// Refer to mesh::TreeLoadBalancer for input
TreeLoadBalancer {
  DEV_report_load_balance = TRUE
  DEV_barrier_before = FALSE
  DEV_barrier_after = FALSE
  DEV_balance_penalty_wt = 1.0
  DEV_surface_penalty_wt = 1.0

  // Debugging options
  DEV_check_map = FALSE
  DEV_check_connectivity = FALSE
  DEV_print_steps = FALSE
  DEV_print_swap_steps = FALSE
  DEV_print_break_steps = FALSE
  DEV_print_edge_steps = FALSE
}

// Refer to hier::PatchHierarchy for input
PatchHierarchy {
   max_levels = 4
   proper_nesting_buffer = 2, 2, 2, 2, 2, 2
   largest_patch_size {
      // level_0 = 20, 20
      level_0 = -1, -1
      // all finer levels will use same values as level_0...
   }
   smallest_patch_size {
      level_0 = 4,4
      // all finer levels will use same values as level_0...
   }
   ratio_to_coarser {
      level_1            = 2, 2
      level_2            = 2, 2
      level_3            = 2, 2
      level_4            = 2, 2
      level_5            = 2, 2
      level_6            = 2, 2
      level_7            = 2, 2
      level_8            = 2, 2
      level_9            = 2, 2
      //  etc.
   }
   allow_patches_smaller_than_ghostwidth = FALSE
   allow_patches_smaller_than_minimum_size_to_prevent_overlaps = TRUE
}

// Refer to mesh::GriddingAlgorithm for input
GriddingAlgorithm {
   enforce_proper_nesting = TRUE
   DEV_extend_to_domain_boundary = FALSE
   // DEV_load_balance = FALSE
   check_nonrefined_tags = "WARN"
   check_overlapping_patches = "WARN"
   sequentialize_patch_indices = TRUE

   check_overflow_nesting = FALSE
   check_proper_nesting = TRUE
   DEV_check_connectors = FALSE
   DEV_print_steps = FALSE
}

// Refer to tbox::TimerManager for input
TimerManager{
  timer_list = "*::*::*"
  print_user = TRUE
  // print_timer_overhead = TRUE
  print_threshold = 0
  print_summed = TRUE
  print_max = TRUE
}
